package com.polymorphic;
/*
 * 关于多态中涉及的几个概念：
 * 	  向上转型
 * 		子类型-->父类型
 * 		又被称为：自动类型装换
 * 	向下转型
 * 		父类型-->子类型
 * 		又被称为：强制类型装换【需要加强制类型转行符】
 *  需要记忆：
 *  无论是向上转型还是向下转型，两种类型之间必须有继承关系
 *  没有继承关系，程序是无法编译通过的
 * */
public class Test {

	public static void main(String[] args) {
		
		/*3.new Cat()创建的对象的类型是Cat,a2这个引用的数据类型是Animal,可见它们进行了
		类型转换，子类型转换成父类型，称为向上转型，或者称为自动类型转换
		4.java中允许这种语法：父类型引用指向子类型对象
		*/
		Animal a2 = new Cat();
		/* 1.java程序永远都分为编译阶段和运行阶段
		 * 2.先分析编译阶段，再分析运行阶段，编译无法通过，根本是无法运行的
		 * 3.编译阶段编译器检查a2这个引用的数据类型为Animal,由于Animal.class字节码当中有
		 * move()方法，所以编译通过了。这个过程我们称为静态绑定，编译阶段绑定。只有静态绑定成功之后才有
		 * 后续的运行
		 * 4.在程序运行阶段，JVM堆内存当中真实创建的对象是Cat对象，那么以下程序在运行阶段一定会调用
		 * Cata对象的move()方法。此时发生了程序的动态绑定，运行阶段绑定。
		 * 5.无论是Cat类有没有重写move方法，运行阶段一定调用的是Cat对象的move方法，因为底层真实对象就是Cat对象
		 * 6.父类型引用指向子类型对象这种机制导致程序存在编译阶段和运行阶段绑定两种不同的形态/状态。这种机制可以称为
		 * 多态机制。
		 * */
		a2.move();
		/*
		 * 分析以下程序为什么不能调用？
		 * 	  因为编译阶段编译器检查到a2的类型是Animal类型，从Animal.class字节码文件当中
		 *   查找catchMouse()方法，最终没找到该方法，导致静态绑定失败，没有绑定成功，也就是
		 *   说编译失败了，别谈运行了。
		 * 
		 * */
		//a2.catchMouse();
		/*
		 * 假想让以上的对象执行catchMouse方法，怎么办？
		 * a2是无法直接调用的，因为a2的类型Animal,Animal中没有catchMouse方法
		 * 		我们可以将a2类型强制转换为Cat类型
		 * 		a2的类型是Animal(父类)，转换成Cat类型(子类)，被称为向下转型/downcasting/强制类型转换
		 * 
		 * 		注意：向下转型也需要两种类型之间必须有继承关系，不然编译报错。强制类型转换需要加强制类型转行符
		 * 	什么时候需要使用向下转型呢？
		 * 		当调用的方法时子类型特有的，在父类型当中不存在，必须进行向下转型
		 * */
		Cat c2 = (Cat)a2;
		c2.catchMouse();
		/*
		 * long x = 100L;
		 * int i = (int)x;
		 * 
		 * */
		
		Animal a3 = new Bird();
		/*
		 * 1.以下程序编译时没有问题的，因为编译器检查到a3的数据类型是Animal
		 * Animal和Cat之间存在继承关系，并且Animal是父类型，Cat是子类型
		 * 父类型转换成子类型叫做向下转型，语法合格
		 * 2.程序虽然编译通过了，但是程序在程序运行阶段会出现异常，因为JVM堆内存
		 * 当中真实存在的对象是Bird对象，Bird对象无法转换成Cat对象，因为两种类型
		 * 之间不存在任何继承关系，此时出现了著名的异常：
		 * Java.lang.ClassCastException
		 * 		类型转换异常，这种异常总是在"向下转型"的时候会发生
		 * 		
		 * */
		
		//Cat c3 = (Cat)a3;
		
		/*向上转型只要编译通过，运行一定不会出现问题：Animal a = new Cat();
		 * 向下转型编译通过，运行可能错误：Animal a2 = new Bird();Cat c3 = (Cat)a3;
		 * 怎么避免向下转型出现的ClassCastException呢？
		 * 	  使用instanceOf运算符可以避免出现以上的异常
		 * 
		 * Java规范中要求：在进行强制类型转换之前，建议采用instanceof运算符进行判断，避免ClassCastException
		 * 异常的发生，这是一个编程好习惯。
		 * */
		
		//正确用法：
		if(a3 instanceof Cat){
			Cat c4 = (Cat)a3;
			c4.catchMouse();
		} else if(a3 instanceof Bird) {
			Bird b4 = (Bird)a3;
			b4.fly();
		}
		
	}

}